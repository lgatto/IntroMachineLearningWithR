<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Chapter 5 Supervised Learning | An Introduction to Machine Learning with R</title>
  <meta name="description" content="An hands-on introduction to machine learning with R.">
  <meta name="generator" content="bookdown  and GitBook 2.6.7">

  <meta property="og:title" content="Chapter 5 Supervised Learning | An Introduction to Machine Learning with R" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="An hands-on introduction to machine learning with R." />
  <meta name="github-repo" content="lgatto/IntroMachineLearningWithR" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 5 Supervised Learning | An Introduction to Machine Learning with R" />
  
  <meta name="twitter:description" content="An hands-on introduction to machine learning with R." />
  

<meta name="author" content="Laurent Gatto">


<meta name="date" content="2019-04-24">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="unsupervised-learning.html">
<link rel="next" href="final-notes.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/htmlwidgets-1.3/htmlwidgets.js"></script>
<link href="libs/datatables-css-0.0.0/datatables-crosstalk.css" rel="stylesheet" />
<script src="libs/datatables-binding-0.5/datatables.js"></script>
<link href="libs/dt-core-1.10.16/css/jquery.dataTables.min.css" rel="stylesheet" />
<link href="libs/dt-core-1.10.16/css/jquery.dataTables.extra.css" rel="stylesheet" />
<script src="libs/dt-core-1.10.16/js/jquery.dataTables.min.js"></script>
<link href="libs/crosstalk-1.0.0/css/crosstalk.css" rel="stylesheet" />
<script src="libs/crosstalk-1.0.0/js/crosstalk.min.js"></script>


<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Preface</a><ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#caution"><i class="fa fa-check"></i><b>1.1</b> Caution</a></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#installation"><i class="fa fa-check"></i><b>1.2</b> Installation</a></li>
<li class="chapter" data-level="1.3" data-path="index.html"><a href="index.html#license"><i class="fa fa-check"></i><b>1.3</b> License</a></li>
<li class="chapter" data-level="1.4" data-path="index.html"><a href="index.html#contact"><i class="fa fa-check"></i><b>1.4</b> Contact</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="an-introduction-to-machine-learning-with-r.html"><a href="an-introduction-to-machine-learning-with-r.html"><i class="fa fa-check"></i><b>2</b> An Introduction to Machine Learning with R</a><ul>
<li class="chapter" data-level="2.1" data-path="an-introduction-to-machine-learning-with-r.html"><a href="an-introduction-to-machine-learning-with-r.html#objectives-and-pre-requisites"><i class="fa fa-check"></i><b>2.1</b> Objectives and pre-requisites</a></li>
<li class="chapter" data-level="2.2" data-path="an-introduction-to-machine-learning-with-r.html"><a href="an-introduction-to-machine-learning-with-r.html#why-r"><i class="fa fa-check"></i><b>2.2</b> Why R?</a></li>
<li class="chapter" data-level="2.3" data-path="an-introduction-to-machine-learning-with-r.html"><a href="an-introduction-to-machine-learning-with-r.html#overview-of-machine-learning-ml"><i class="fa fa-check"></i><b>2.3</b> Overview of machine learning (ML)</a></li>
<li class="chapter" data-level="2.4" data-path="an-introduction-to-machine-learning-with-r.html"><a href="an-introduction-to-machine-learning-with-r.html#material-and-methods"><i class="fa fa-check"></i><b>2.4</b> Material and methods</a><ul>
<li class="chapter" data-level="2.4.1" data-path="an-introduction-to-machine-learning-with-r.html"><a href="an-introduction-to-machine-learning-with-r.html#example-data"><i class="fa fa-check"></i><b>2.4.1</b> Example data</a></li>
<li class="chapter" data-level="2.4.2" data-path="an-introduction-to-machine-learning-with-r.html"><a href="an-introduction-to-machine-learning-with-r.html#packages"><i class="fa fa-check"></i><b>2.4.2</b> Packages</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="example-datasets.html"><a href="example-datasets.html"><i class="fa fa-check"></i><b>3</b> Example datasets</a><ul>
<li class="chapter" data-level="3.1" data-path="example-datasets.html"><a href="example-datasets.html#edgar-andersons-iris-data"><i class="fa fa-check"></i><b>3.1</b> Edgar Anderson’s Iris Data</a></li>
<li class="chapter" data-level="3.2" data-path="example-datasets.html"><a href="example-datasets.html#motor-trend-car-road-tests"><i class="fa fa-check"></i><b>3.2</b> Motor Trend Car Road Tests</a></li>
<li class="chapter" data-level="3.3" data-path="example-datasets.html"><a href="example-datasets.html#sub-cellular-localisation"><i class="fa fa-check"></i><b>3.3</b> Sub-cellular localisation</a></li>
<li class="chapter" data-level="3.4" data-path="example-datasets.html"><a href="example-datasets.html#the-diamonds-data"><i class="fa fa-check"></i><b>3.4</b> The diamonds data</a></li>
<li class="chapter" data-level="3.5" data-path="example-datasets.html"><a href="example-datasets.html#the-sonar-data"><i class="fa fa-check"></i><b>3.5</b> The Sonar data</a></li>
<li class="chapter" data-level="3.6" data-path="example-datasets.html"><a href="example-datasets.html#housing-values-in-suburbs-of-boston"><i class="fa fa-check"></i><b>3.6</b> Housing Values in Suburbs of Boston</a></li>
<li class="chapter" data-level="3.7" data-path="example-datasets.html"><a href="example-datasets.html#customer-churn"><i class="fa fa-check"></i><b>3.7</b> Customer churn</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html"><i class="fa fa-check"></i><b>4</b> Unsupervised Learning</a><ul>
<li class="chapter" data-level="4.1" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#introduction"><i class="fa fa-check"></i><b>4.1</b> Introduction</a></li>
<li class="chapter" data-level="4.2" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#k-means-clustering"><i class="fa fa-check"></i><b>4.2</b> k-means clustering</a><ul>
<li class="chapter" data-level="4.2.1" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#how-does-k-means-work"><i class="fa fa-check"></i><b>4.2.1</b> How does k-means work</a></li>
<li class="chapter" data-level="4.2.2" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#model-selection"><i class="fa fa-check"></i><b>4.2.2</b> Model selection</a></li>
<li class="chapter" data-level="4.2.3" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#how-to-determine-the-number-of-clusters"><i class="fa fa-check"></i><b>4.2.3</b> How to determine the number of clusters</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#hierarchical-clustering"><i class="fa fa-check"></i><b>4.3</b> Hierarchical clustering</a><ul>
<li class="chapter" data-level="4.3.1" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#how-does-hierarchical-clustering-work"><i class="fa fa-check"></i><b>4.3.1</b> How does hierarchical clustering work</a></li>
<li class="chapter" data-level="4.3.2" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#defining-clusters"><i class="fa fa-check"></i><b>4.3.2</b> Defining clusters</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#pre-processing"><i class="fa fa-check"></i><b>4.4</b> Pre-processing</a></li>
<li class="chapter" data-level="4.5" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#principal-component-analysis-pca"><i class="fa fa-check"></i><b>4.5</b> Principal component analysis (PCA)</a><ul>
<li class="chapter" data-level="4.5.1" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#how-does-it-work"><i class="fa fa-check"></i><b>4.5.1</b> How does it work</a></li>
<li class="chapter" data-level="4.5.2" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#visualisation"><i class="fa fa-check"></i><b>4.5.2</b> Visualisation</a></li>
<li class="chapter" data-level="4.5.3" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#data-pre-processing"><i class="fa fa-check"></i><b>4.5.3</b> Data pre-processing</a></li>
<li class="chapter" data-level="4.5.4" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#final-comments-on-pca"><i class="fa fa-check"></i><b>4.5.4</b> Final comments on PCA</a></li>
</ul></li>
<li class="chapter" data-level="4.6" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#t-distributed-stochastic-neighbour-embedding"><i class="fa fa-check"></i><b>4.6</b> t-Distributed Stochastic Neighbour Embedding</a><ul>
<li class="chapter" data-level="4.6.1" data-path="unsupervised-learning.html"><a href="unsupervised-learning.html#parameter-tuning"><i class="fa fa-check"></i><b>4.6.1</b> Parameter tuning</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="supervised-learning.html"><a href="supervised-learning.html"><i class="fa fa-check"></i><b>5</b> Supervised Learning</a><ul>
<li class="chapter" data-level="5.1" data-path="supervised-learning.html"><a href="supervised-learning.html#introduction-1"><i class="fa fa-check"></i><b>5.1</b> Introduction</a></li>
<li class="chapter" data-level="5.2" data-path="supervised-learning.html"><a href="supervised-learning.html#preview"><i class="fa fa-check"></i><b>5.2</b> Preview</a></li>
<li class="chapter" data-level="5.3" data-path="supervised-learning.html"><a href="supervised-learning.html#model-performance"><i class="fa fa-check"></i><b>5.3</b> Model performance</a><ul>
<li class="chapter" data-level="5.3.1" data-path="supervised-learning.html"><a href="supervised-learning.html#in-sample-and-out-of-sample-error"><i class="fa fa-check"></i><b>5.3.1</b> In-sample and out-of-sample error</a></li>
<li class="chapter" data-level="5.3.2" data-path="supervised-learning.html"><a href="supervised-learning.html#cross-validation"><i class="fa fa-check"></i><b>5.3.2</b> Cross-validation</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="supervised-learning.html"><a href="supervised-learning.html#classification-performance"><i class="fa fa-check"></i><b>5.4</b> Classification performance</a><ul>
<li class="chapter" data-level="5.4.1" data-path="supervised-learning.html"><a href="supervised-learning.html#confusion-matrix"><i class="fa fa-check"></i><b>5.4.1</b> Confusion matrix</a></li>
<li class="chapter" data-level="5.4.2" data-path="supervised-learning.html"><a href="supervised-learning.html#receiver-operating-characteristic-roc-curve"><i class="fa fa-check"></i><b>5.4.2</b> Receiver operating characteristic (ROC) curve</a></li>
<li class="chapter" data-level="5.4.3" data-path="supervised-learning.html"><a href="supervised-learning.html#auc-in-caret"><i class="fa fa-check"></i><b>5.4.3</b> AUC in <code>caret</code></a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="supervised-learning.html"><a href="supervised-learning.html#random-forest"><i class="fa fa-check"></i><b>5.5</b> Random forest</a><ul>
<li class="chapter" data-level="5.5.1" data-path="supervised-learning.html"><a href="supervised-learning.html#decision-trees"><i class="fa fa-check"></i><b>5.5.1</b> Decision trees</a></li>
<li class="chapter" data-level="5.5.2" data-path="supervised-learning.html"><a href="supervised-learning.html#training-a-random-forest"><i class="fa fa-check"></i><b>5.5.2</b> Training a random forest</a></li>
</ul></li>
<li class="chapter" data-level="5.6" data-path="supervised-learning.html"><a href="supervised-learning.html#data-pre-processing-1"><i class="fa fa-check"></i><b>5.6</b> Data pre-processing</a><ul>
<li class="chapter" data-level="5.6.1" data-path="supervised-learning.html"><a href="supervised-learning.html#missing-values"><i class="fa fa-check"></i><b>5.6.1</b> Missing values</a></li>
<li class="chapter" data-level="5.6.2" data-path="supervised-learning.html"><a href="supervised-learning.html#median-imputation"><i class="fa fa-check"></i><b>5.6.2</b> Median imputation</a></li>
<li class="chapter" data-level="5.6.3" data-path="supervised-learning.html"><a href="supervised-learning.html#knn-imputation"><i class="fa fa-check"></i><b>5.6.3</b> kNN imputation</a></li>
</ul></li>
<li class="chapter" data-level="5.7" data-path="supervised-learning.html"><a href="supervised-learning.html#scaling-and-centering"><i class="fa fa-check"></i><b>5.7</b> Scaling and centering</a><ul>
<li class="chapter" data-level="5.7.1" data-path="supervised-learning.html"><a href="supervised-learning.html#multiple-pre-processing-methods"><i class="fa fa-check"></i><b>5.7.1</b> Multiple pre-processing methods</a></li>
</ul></li>
<li class="chapter" data-level="5.8" data-path="supervised-learning.html"><a href="supervised-learning.html#model-selection-1"><i class="fa fa-check"></i><b>5.8</b> Model selection</a><ul>
<li class="chapter" data-level="5.8.1" data-path="supervised-learning.html"><a href="supervised-learning.html#glmnet-model"><i class="fa fa-check"></i><b>5.8.1</b> <code>glmnet</code> model</a></li>
<li class="chapter" data-level="5.8.2" data-path="supervised-learning.html"><a href="supervised-learning.html#random-forest-model"><i class="fa fa-check"></i><b>5.8.2</b> random forest model</a></li>
<li class="chapter" data-level="5.8.3" data-path="supervised-learning.html"><a href="supervised-learning.html#knn-model"><i class="fa fa-check"></i><b>5.8.3</b> kNN model</a></li>
<li class="chapter" data-level="5.8.4" data-path="supervised-learning.html"><a href="supervised-learning.html#support-vector-machine-model"><i class="fa fa-check"></i><b>5.8.4</b> Support vector machine model</a></li>
<li class="chapter" data-level="5.8.5" data-path="supervised-learning.html"><a href="supervised-learning.html#naive-bayes"><i class="fa fa-check"></i><b>5.8.5</b> Naive Bayes</a></li>
<li class="chapter" data-level="5.8.6" data-path="supervised-learning.html"><a href="supervised-learning.html#comparing-models"><i class="fa fa-check"></i><b>5.8.6</b> Comparing models</a></li>
<li class="chapter" data-level="5.8.7" data-path="supervised-learning.html"><a href="supervised-learning.html#pre-processing-1"><i class="fa fa-check"></i><b>5.8.7</b> Pre-processing</a></li>
<li class="chapter" data-level="5.8.8" data-path="supervised-learning.html"><a href="supervised-learning.html#predict-using-the-best-model"><i class="fa fa-check"></i><b>5.8.8</b> Predict using the best model</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="final-notes.html"><a href="final-notes.html"><i class="fa fa-check"></i><b>6</b> Final notes</a><ul>
<li class="chapter" data-level="6.1" data-path="final-notes.html"><a href="final-notes.html#other-learning-algorithms"><i class="fa fa-check"></i><b>6.1</b> Other learning algorithms</a><ul>
<li class="chapter" data-level="" data-path="final-notes.html"><a href="final-notes.html#semi-supervised-learning"><i class="fa fa-check"></i>Semi-supervised learning</a></li>
<li class="chapter" data-level="" data-path="final-notes.html"><a href="final-notes.html#deep-learning-in-r"><i class="fa fa-check"></i>Deep learning in R</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="final-notes.html"><a href="final-notes.html#model-performance-1"><i class="fa fa-check"></i><b>6.2</b> Model performance</a></li>
<li class="chapter" data-level="6.3" data-path="final-notes.html"><a href="final-notes.html#credit-and-acknowledgements"><i class="fa fa-check"></i><b>6.3</b> Credit and acknowledgements</a></li>
<li class="chapter" data-level="6.4" data-path="final-notes.html"><a href="final-notes.html#references-and-further-reading"><i class="fa fa-check"></i><b>6.4</b> References and further reading</a></li>
<li class="chapter" data-level="6.5" data-path="final-notes.html"><a href="final-notes.html#session-information"><i class="fa fa-check"></i><b>6.5</b> Session information</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">An Introduction to Machine Learning with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="supervised-learning" class="section level1">
<h1><span class="header-section-number">Chapter 5</span> Supervised Learning</h1>
<div id="introduction-1" class="section level2">
<h2><span class="header-section-number">5.1</span> Introduction</h2>
<p>In <strong>supervised learning</strong> (SML), the learning algorithm is presented
with labelled example inputs, where the labels indicate the desired
output. SML itself is composed of <strong>classification</strong>, where the output
is qualitative, and <strong>regression</strong>, where the output is quantitative.</p>
<p>When two sets of labels, or classes, are available, one speaks of
<strong>binary classification</strong>. A classical example thereof is labelling an
email as <em>spam</em> or <em>not spam</em>. When more classes are to be learnt, one
speaks of a <strong>multi-class problem</strong>, such as annotation of a new <em>Iris</em>
example as being from the <em>setosa</em>, <em>versicolor</em> or <em>virginica</em>
species. In these cases, the output is a single label (of one of the
anticipated classes). If multiple labels may be assigned to each
example, one speaks of <strong>multi-label classification</strong>.</p>
</div>
<div id="preview" class="section level2">
<h2><span class="header-section-number">5.2</span> Preview</h2>
<p>To start this chapter, let’s use a simple, but useful classification
algorithm, k-nearest neighbours (kNN) to classify the <em>iris</em>
flowers. We will use the <code>knn</code> function from the <em><a href="https://CRAN.R-project.org/package=class">class</a></em>
package.</p>
<p>K-nearest neighbours works by directly measuring the (Euclidean)
distance between observations and inferring the class of unlabelled data
from the class of its nearest neighbours. In the figure below, the
unlabelled instances <em>1</em> and <em>2</em> will be assigned classes <em>c1</em> (blue)
and <em>c2</em> (red) as their closest neighbours are red and blue,
respectively.</p>
<div class="figure"><span id="fig:knnex"></span>
<img src="IntroMachineLearningWithR_files/figure-html/knnex-1.png" alt="Schematic illustrating the k nearest neighbors algorithm." width="672" />
<p class="caption">
Figure 5.1: Schematic illustrating the k nearest neighbors algorithm.
</p>
</div>
<p>Typically in machine learning, there are two clear steps, where one
first <strong>trains</strong> a model and then uses the model to <strong>predict</strong> new
outputs (class labels in this case). In the kNN, these two steps are
combined into a single function call to <code>knn</code>.</p>
<p>Lets draw a set of 50 random iris observations to train the model and
predict the species of another set of 50 randomly chosen flowers. The
<code>knn</code> function takes the training data, the new data (to be inferred)
and the labels of the training data, and returns (by default) the
predicted class.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(12L)
tr &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">150</span>, <span class="dv">50</span>)
nw &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">150</span>, <span class="dv">50</span>)
<span class="kw">library</span>(<span class="st">&quot;class&quot;</span>)
knnres &lt;-<span class="st"> </span><span class="kw">knn</span>(iris[tr, <span class="dv">-5</span>], iris[nw, <span class="dv">-5</span>], iris<span class="op">$</span>Species[tr])
<span class="kw">head</span>(knnres)</code></pre>
<pre><code>## [1] versicolor setosa     versicolor setosa     setosa     setosa    
## Levels: setosa versicolor virginica</code></pre>
<p>We can now compare the observed kNN-predicted class and the expected
known outcome and calculate the overall accuracy of our model.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(knnres, iris<span class="op">$</span>Species[nw])</code></pre>
<pre><code>##             
## knnres       setosa versicolor virginica
##   setosa         20          0         0
##   versicolor      0         17         2
##   virginica       0          0        11</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(knnres <span class="op">==</span><span class="st"> </span>iris<span class="op">$</span>Species[nw])</code></pre>
<pre><code>## [1] 0.96</code></pre>
<p>We have omitted an important argument from <code>knn</code>, which is the
parameter <em>k</em> of the classifier. This parameter defines how many
nearest neighbours will be considered to assign a class to a new
unlabelled observation. From the arguments of the function,</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">args</span>(knn)</code></pre>
<pre><code>## function (train, test, cl, k = 1, l = 0, prob = FALSE, use.all = TRUE) 
## NULL</code></pre>
<p>we see that the default value is 1. But is this a good value? Wouldn’t
we prefer to look at more neighbours and infer the new class using a
vote based on more labels?</p>
<blockquote>
<p>Challenge</p>
<p>Repeat the kNN classification above by using another value of k, and
compare the accuracy of this new model to the one above. Make sure
to use the same <code>tr</code> and <code>nw</code> training and new data to avoid any
biases in the comparison.</p>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r">knnres5 &lt;-<span class="st"> </span><span class="kw">knn</span>(iris[tr, <span class="dv">-5</span>], iris[nw, <span class="dv">-5</span>], iris<span class="op">$</span>Species[tr], <span class="dt">k =</span> <span class="dv">5</span>)
<span class="kw">mean</span>(knnres5 <span class="op">==</span><span class="st"> </span>iris<span class="op">$</span>Species[nw])</code></pre>
<pre><code>## [1] 0.94</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(knnres5, knnres)</code></pre>
<pre><code>##             knnres
## knnres5      setosa versicolor virginica
##   setosa         20          0         0
##   versicolor      0         19         1
##   virginica       0          0        10</code></pre>
</details>
<blockquote>
<p>Challenge</p>
<p>Rerun the kNN classifier with a value of <em>k</em> &gt; 1, and specify <code>prob = TRUE</code> to obtain the proportion of the votes for the winning class.</p>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r">knnres5prob &lt;-<span class="st"> </span><span class="kw">knn</span>(iris[tr, <span class="dv">-5</span>], iris[nw, <span class="dv">-5</span>], iris<span class="op">$</span>Species[tr], <span class="dt">k =</span> <span class="dv">5</span>, <span class="dt">prob =</span> <span class="ot">TRUE</span>)
<span class="kw">table</span>(<span class="kw">attr</span>(knnres5prob, <span class="st">&quot;prob&quot;</span>))</code></pre>
<pre><code>## 
##               0.6               0.8 0.833333333333333                 1 
##                 3                13                 1                33</code></pre>
</details>
<p>This introductory example leads to two important and related questions
that we need to consider:</p>
<ul>
<li><p>How can we do a good job in training and testing data? In the
example above, we choose random training and new data.</p></li>
<li><p>How can we estimate our model parameters (<em>k</em> in the example above)
so as to obtain good classification accuracy?</p></li>
</ul>
</div>
<div id="model-performance" class="section level2">
<h2><span class="header-section-number">5.3</span> Model performance</h2>
<div id="in-sample-and-out-of-sample-error" class="section level3">
<h3><span class="header-section-number">5.3.1</span> In-sample and out-of-sample error</h3>
<p>In supervised machine learning, we have a desired output and thus know
precisely what is to be computed. It thus becomes possible to directly
evaluate a model using a quantifiable and objective metric. For
regression, we will use the <strong>root mean squared error</strong> (RMSE), which
is what linear regression (<code>lm</code> in R) seeks to minimise. For
classification, we will use <strong>model prediction accuracy</strong>.</p>
<p>Typically, we won’t want to calculate any of these metrics using
observations that were also used to calculate the model. This
approach, called <strong>in-sample error</strong> leads to optimistic assessment of
our model. Indeed, the model has already <em>seen</em> these data upon
construction, and is considered optimised for these observations
in particular; it is said to <strong>over-fit</strong> the data. We prefer to
calculate an <strong>out-of-sample error</strong>, on new data, to gain a better
idea of how to model performs on unseen data, and estimate how well
the model <strong>generalises</strong>.</p>
<p>In this course, we will focus on the <em><a href="https://CRAN.R-project.org/package=caret">caret</a></em> package for
Classification And REgression Training (see also
<a href="https://topepo.github.io/caret/index.html" class="uri">https://topepo.github.io/caret/index.html</a>). It provides a common and
consistent interface to many, often repetitive, tasks in supervised
learning.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;caret&quot;</span>)</code></pre>
<p>The code chunk below uses the <code>lm</code> function to model the price of
round cut diamonds and then predicts the price of these very same
diamonds with the <code>predict</code> function.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(diamonds)
model &lt;-<span class="st"> </span><span class="kw">lm</span>(price <span class="op">~</span><span class="st"> </span>., diamonds)
p &lt;-<span class="st"> </span><span class="kw">predict</span>(model, diamonds)</code></pre>
<blockquote>
<p>Challenge</p>
<p>Calculate the root mean squared error for the prediction above</p>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">## Error on prediction</span>
error &lt;-<span class="st"> </span>p <span class="op">-</span><span class="st"> </span>diamonds<span class="op">$</span>price
rmse_in &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">mean</span>(error<span class="op">^</span><span class="dv">2</span>)) <span class="co">## in-sample RMSE</span>
rmse_in</code></pre>
<pre><code>## [1] 1129.843</code></pre>
</details>
<p>Let’s now repeat the exercise above, but by calculating the
out-of-sample RMSE. We prepare a 80/20 split of the data and use
80% to fit our model, and predict the target variable (this is called the
<strong>training data</strong>), the price, on the 20% of unseen data (the <strong>testing
data</strong>).</p>
<blockquote>
<p>Challenge</p>
<ol style="list-style-type: decimal">
<li>Let’s create a <strong>random</strong> 80/20 split to define the test and
train subsets.</li>
<li>Train a regression model on the training data.</li>
<li>Test the model on the testing data.</li>
<li>Calculating the out-of-sample RMSE.</li>
</ol>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">42</span>)
ntest &lt;-<span class="st"> </span><span class="kw">nrow</span>(diamonds) <span class="op">*</span><span class="st"> </span><span class="fl">0.80</span>
test &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">nrow</span>(diamonds), ntest)
model &lt;-<span class="st"> </span><span class="kw">lm</span>(price <span class="op">~</span><span class="st"> </span>., <span class="dt">data =</span> diamonds[test, ])
p &lt;-<span class="st"> </span><span class="kw">predict</span>(model, diamonds[<span class="op">-</span>test, ])
error &lt;-<span class="st"> </span>p <span class="op">-</span><span class="st"> </span>diamonds<span class="op">$</span>price[<span class="op">-</span>test]
rmse_out &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">mean</span>(error<span class="op">^</span><span class="dv">2</span>)) <span class="co">## out-of-sample RMSE</span>
rmse_out</code></pre>
<pre><code>## [1] 1137.466</code></pre>
</details>
<p>The values for the out-of-sample RMSE will vary depending on what
exact split was used. The diamonds is a rather extensive data set, and
thus even when building our model using a subset of the available data
(80% above), we manage to generate a model with a low RMSE, and
possibly lower than the in-sample error.</p>
<p>When dealing with datasets of smaller sizes, however, the presence of
a single outlier in the train and test data split can substantially
influence the model and the RMSE. We can’t rely on such an approach and
need a more robust one where we can generate and use multiple,
different train/test sets to sample a set of RMSEs, leading to a
better estimate of the out-of-sample RMSE.</p>
</div>
<div id="cross-validation" class="section level3">
<h3><span class="header-section-number">5.3.2</span> Cross-validation</h3>
<p>Instead of doing a single training/testing split, we can systematise
this process, produce multiple, different out-of-sample train/test
splits, that will lead to a better estimate of the out-of-sample RMSE.</p>
<p>The figure below illustrates the cross validation procedure, creating
3 folds. One would typically do a 10-fold cross validation (if the
size of the data permits it). We split the data into 3 <em>random</em> and
complementary folds, so that each data point appears exactly once in
each fold. This leads to a total test set size that is identical to
the size of the full dataset but is composed of out-of-sample
predictions.</p>
<div class="figure">
<img src="figure/xval.png" alt="Schematic of 3-fold cross validation producing three training (blue) and testing (white) splits." />
<p class="caption">Schematic of 3-fold cross validation producing three training (blue) and testing (white) splits.</p>
</div>
<p>After cross-validation, all models used within each fold are
discarded, and a new model is built using the whole dataset, with the
best model parameter(s), i.e those that generalised over all folds.</p>
<p>This makes cross-validation quite time consuming, as it takes <em>x+1</em>
(where <em>x</em> in the number of cross-validation folds) times as long as
fitting a single model, but is essential.</p>
<p>Note that it is important to maintain the class proportions within the
different folds, i.e. respect the proportion of the different classes
in the original data. This is also taken care when using the
<em><a href="https://CRAN.R-project.org/package=caret">caret</a></em> package.</p>
<p>The procedure of creating folds and training the models is handled by
the <code>train</code> function in <em><a href="https://CRAN.R-project.org/package=caret">caret</a></em>. Below, we apply it to
the diamond price example that we used when introducing the model
performance.</p>
<ul>
<li>We start by setting a random seed to be able to reproduce the example.</li>
<li>We specify the method (the learning algorithm) we want to use. Here,
we use <code>"lm"</code>, but, as we will see later, there are many others to
choose from<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</li>
<li>We then set the out-of-sample training procedure to 10-fold cross
validation (<code>method = "cv"</code> and <code>number = 10</code>). To simplify the
output in the material for better readability, we set the verbosity
flag to <code>FALSE</code>, but it is useful to set it to <code>TRUE</code> in interactive
mode.</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">42</span>)
model &lt;-<span class="st"> </span><span class="kw">train</span>(price <span class="op">~</span><span class="st"> </span>., diamonds,
               <span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>,
               <span class="dt">trControl =</span> <span class="kw">trainControl</span>(<span class="dt">method =</span> <span class="st">&quot;cv&quot;</span>,
                                        <span class="dt">number =</span> <span class="dv">10</span>,
                                        <span class="dt">verboseIter =</span> <span class="ot">FALSE</span>))
model</code></pre>
<pre><code>## Linear Regression 
## 
## 53940 samples
##     9 predictor
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold) 
## Summary of sample sizes: 48547, 48545, 48546, 48545, 48546, 48546, ... 
## Resampling results:
## 
##   RMSE      Rsquared   MAE     
##   1130.819  0.9197489  740.5712
## 
## Tuning parameter &#39;intercept&#39; was held constant at a value of TRUE</code></pre>
<p>Once we have trained our model, we can directly use this <code>train</code>
object as input to the <code>predict</code> method:</p>
<pre class="sourceCode r"><code class="sourceCode r">p &lt;-<span class="st"> </span><span class="kw">predict</span>(model, diamonds)
error &lt;-<span class="st"> </span>p <span class="op">-</span><span class="st"> </span>diamonds<span class="op">$</span>price
rmse_xval &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">mean</span>(error<span class="op">^</span><span class="dv">2</span>)) <span class="co">## xval RMSE</span>
rmse_xval</code></pre>
<pre><code>## [1] 1129.843</code></pre>
<blockquote>
<p>Challenge</p>
<p>Train a linear model using 10-fold cross-validation and then use it
to predict the median value of owner-occupied homes in Boston from
the <code>Boston</code> dataset as described above. Then calculate the RMSE.</p>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;MASS&quot;</span>)
<span class="kw">data</span>(Boston)
model &lt;-<span class="st"> </span><span class="kw">train</span>(medv <span class="op">~</span><span class="st"> </span>.,
               Boston,
               <span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>,
               <span class="dt">trControl =</span> <span class="kw">trainControl</span>(<span class="dt">method =</span> <span class="st">&quot;cv&quot;</span>,
                                        <span class="dt">number =</span> <span class="dv">10</span>))
model</code></pre>
<pre><code>## Linear Regression 
## 
## 506 samples
##  13 predictor
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold) 
## Summary of sample sizes: 455, 456, 457, 456, 454, 456, ... 
## Resampling results:
## 
##   RMSE      Rsquared   MAE     
##   4.838479  0.7301286  3.433261
## 
## Tuning parameter &#39;intercept&#39; was held constant at a value of TRUE</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">p &lt;-<span class="st"> </span><span class="kw">predict</span>(model, Boston)
<span class="kw">sqrt</span>(<span class="kw">mean</span>(p <span class="op">-</span><span class="st"> </span>Boston<span class="op">$</span>medv)<span class="op">^</span><span class="dv">2</span>)</code></pre>
<pre><code>## [1] 6.647482e-14</code></pre>
</details>
</div>
</div>
<div id="classification-performance" class="section level2">
<h2><span class="header-section-number">5.4</span> Classification performance</h2>
<p>Above, we have used the RMSE to assess the performance of our
regression model. When using a classification algorithm, we want to
assess its accuracy to do so.</p>
<div id="confusion-matrix" class="section level3">
<h3><span class="header-section-number">5.4.1</span> Confusion matrix</h3>
<p>Instead of calculating an error between predicted value and known
value, in classification we will directly compare the predicted
class matches with the known label. To do so, rather than calculating the
mean accuracy as we did above, in the introductory kNN example, we can
calculate a <strong>confusion matrix</strong>.</p>
<p>A confusion matrix contrasts predictions to actual results. Correct
results are <em>true positives</em> (TP) and <em>true negatives</em> (TN) are found
along the diagonal. All other cells indicate false results, i.e <em>false
negatives</em> (FN) and <em>false positives</em> (FP).</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="left">Reference Yes</th>
<th align="left">Reference No</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Predicted Yes</td>
<td align="left">TP</td>
<td align="left">FP</td>
</tr>
<tr class="even">
<td>Predicted No</td>
<td align="left">FN</td>
<td align="left">TN</td>
</tr>
</tbody>
</table>
<p>The values that populate this table will depend on the cutoff that
we set to define whether the classifier should predict <em>Yes</em> or
<em>No</em>. Intuitively, we might want to use 0.5 as a threshold, and assign
every result with a probability &gt; 0.5 to <em>Yes</em> and <em>No</em> otherwise.</p>
<p>Let’s experiment with this using the <code>Sonar</code> dataset, and see if we
can differentiate mines from rocks using a logistic classification
model use the <code>glm</code> function from the <em><a href="https://CRAN.R-project.org/package=stats">stats</a></em> package.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;mlbench&quot;</span>)
<span class="kw">data</span>(Sonar)
<span class="co">## 60/40 split</span>
tr &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">nrow</span>(Sonar), <span class="kw">round</span>(<span class="kw">nrow</span>(Sonar) <span class="op">*</span><span class="st"> </span><span class="fl">0.6</span>))
train &lt;-<span class="st"> </span>Sonar[tr, ]
test &lt;-<span class="st"> </span>Sonar[<span class="op">-</span>tr, ]</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">model &lt;-<span class="st"> </span><span class="kw">glm</span>(Class <span class="op">~</span><span class="st"> </span>., <span class="dt">data =</span> train, <span class="dt">family =</span> <span class="st">&quot;binomial&quot;</span>)
p &lt;-<span class="st"> </span><span class="kw">predict</span>(model, test, <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>)
<span class="kw">summary</span>(p)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.0000  0.0000  0.8545  0.5123  1.0000  1.0000</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">cl &lt;-<span class="st"> </span><span class="kw">ifelse</span>(p <span class="op">&gt;</span><span class="st"> </span><span class="fl">0.5</span>, <span class="st">&quot;M&quot;</span>, <span class="st">&quot;R&quot;</span>)
<span class="kw">table</span>(cl, test<span class="op">$</span>Class)</code></pre>
<pre><code>##    
## cl   M  R
##   M 12 31
##   R 31  9</code></pre>
<p>The caret package offers its own, more informative function to
calculate a confusion matrix:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">confusionMatrix</span>(<span class="kw">factor</span>(cl), test<span class="op">$</span>Class)</code></pre>
<pre><code>## Confusion Matrix and Statistics
## 
##           Reference
## Prediction  M  R
##          M 12 31
##          R 31  9
##                                           
##                Accuracy : 0.253           
##                  95% CI : (0.1639, 0.3604)
##     No Information Rate : 0.5181          
##     P-Value [Acc &gt; NIR] : 1               
##                                           
##                   Kappa : -0.4959         
##                                           
##  Mcnemar&#39;s Test P-Value : 1               
##                                           
##             Sensitivity : 0.2791          
##             Specificity : 0.2250          
##          Pos Pred Value : 0.2791          
##          Neg Pred Value : 0.2250          
##              Prevalence : 0.5181          
##          Detection Rate : 0.1446          
##    Detection Prevalence : 0.5181          
##       Balanced Accuracy : 0.2520          
##                                           
##        &#39;Positive&#39; Class : M               
## </code></pre>
<p>We get, among others</p>
<ul>
<li>the accuracy: <span class="math inline">\(\frac{TP + TN}{TP + TN + FP + FN}\)</span></li>
<li>the sensitivity (recall, TP rate): <span class="math inline">\(\frac{TP}{TP + FN}\)</span></li>
<li>the specificity: <span class="math inline">\(\frac{TN}{TN + FP}\)</span></li>
<li>positive predictive value (precision): <span class="math inline">\(\frac{TP}{TP + FP}\)</span></li>
<li>negative predictive value: <span class="math inline">\(\frac{TN}{TN + FN}\)</span></li>
<li>FP rate (fall-out): <span class="math inline">\(\frac{FP}{FP + TN}\)</span></li>
</ul>
<blockquote>
<p>Challenge</p>
<p>Compare the model accuracy (or any other metric) using thresholds of
0.1 and 0.9.</p>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">confusionMatrix</span>(<span class="kw">factor</span>(<span class="kw">ifelse</span>(p <span class="op">&gt;</span><span class="st"> </span><span class="fl">0.9</span>, <span class="st">&quot;M&quot;</span>, <span class="st">&quot;R&quot;</span>)), test<span class="op">$</span>Class)</code></pre>
<pre><code>## Confusion Matrix and Statistics
## 
##           Reference
## Prediction  M  R
##          M 11 30
##          R 32 10
##                                           
##                Accuracy : 0.253           
##                  95% CI : (0.1639, 0.3604)
##     No Information Rate : 0.5181          
##     P-Value [Acc &gt; NIR] : 1.0000          
##                                           
##                   Kappa : -0.4933         
##                                           
##  Mcnemar&#39;s Test P-Value : 0.8989          
##                                           
##             Sensitivity : 0.2558          
##             Specificity : 0.2500          
##          Pos Pred Value : 0.2683          
##          Neg Pred Value : 0.2381          
##              Prevalence : 0.5181          
##          Detection Rate : 0.1325          
##    Detection Prevalence : 0.4940          
##       Balanced Accuracy : 0.2529          
##                                           
##        &#39;Positive&#39; Class : M               
## </code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">confusionMatrix</span>(<span class="kw">factor</span>(<span class="kw">ifelse</span>(p <span class="op">&gt;</span><span class="st"> </span><span class="fl">0.1</span>, <span class="st">&quot;M&quot;</span>, <span class="st">&quot;R&quot;</span>)), test<span class="op">$</span>Class)</code></pre>
<pre><code>## Confusion Matrix and Statistics
## 
##           Reference
## Prediction  M  R
##          M 12 31
##          R 31  9
##                                           
##                Accuracy : 0.253           
##                  95% CI : (0.1639, 0.3604)
##     No Information Rate : 0.5181          
##     P-Value [Acc &gt; NIR] : 1               
##                                           
##                   Kappa : -0.4959         
##                                           
##  Mcnemar&#39;s Test P-Value : 1               
##                                           
##             Sensitivity : 0.2791          
##             Specificity : 0.2250          
##          Pos Pred Value : 0.2791          
##          Neg Pred Value : 0.2250          
##              Prevalence : 0.5181          
##          Detection Rate : 0.1446          
##    Detection Prevalence : 0.5181          
##       Balanced Accuracy : 0.2520          
##                                           
##        &#39;Positive&#39; Class : M               
## </code></pre>
</details>
</div>
<div id="receiver-operating-characteristic-roc-curve" class="section level3">
<h3><span class="header-section-number">5.4.2</span> Receiver operating characteristic (ROC) curve</h3>
<p>There is no reason to use 0.5 as a threshold. One could use a low
threshold to catch more mines with less certainty or or higher
threshold to catch fewer mines with more certainty.</p>
<p>This illustrates the need to adequately balance TP and FP rates. We
need to have a way to do a cost-benefit analysis, and the solution
will often depend on the question/problem.</p>
<p>One solution would be to try with different classification
thresholds. Instead of inspecting numerous confusion matrices, it is
possible to automate the calculation of the TP and FP rates at each
threshold and visualise all results along a ROC curve.</p>
<p>This can be done with the <code>colAUC</code> function from the
<em><a href="https://CRAN.R-project.org/package=caTools">caTools</a></em> package:</p>
<pre class="sourceCode r"><code class="sourceCode r">caTools<span class="op">::</span><span class="kw">colAUC</span>(p, test[[<span class="st">&quot;Class&quot;</span>]], <span class="dt">plotROC =</span> <span class="ot">TRUE</span>)</code></pre>
<p><img src="IntroMachineLearningWithR_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre><code>##              [,1]
## M vs. R 0.7767442</code></pre>
<ul>
<li>x: FP rate (1 - specificity)</li>
<li>y: TP rate (sensitivity)</li>
<li>each point along the curve represents a confusion matrix for a given
threshold</li>
</ul>
<p>In addition, the <code>colAUC</code> function returns the area under the curve
(AUC) model accuracy metric. This is single number metric, summarising
the model performance along all possible thresholds:</p>
<ul>
<li>an AUC of 0.5 corresponds to a random model</li>
<li>values &gt; 0.5 do better than a random guess</li>
<li>a value of 1 represents a perfect model</li>
<li>a value 0 represents a model that is always wrong</li>
</ul>
</div>
<div id="auc-in-caret" class="section level3">
<h3><span class="header-section-number">5.4.3</span> AUC in <code>caret</code></h3>
<p>When using <em><a href="https://CRAN.R-project.org/package=caret">caret</a></em>’s <code>trainControl</code> function to train a
model, we can set it so that it computes the ROC and AUC properties
for us.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">## Create trainControl object: myControl</span>
myControl &lt;-<span class="st"> </span><span class="kw">trainControl</span>(
    <span class="dt">method =</span> <span class="st">&quot;cv&quot;</span>, <span class="co">## cross validation</span>
    <span class="dt">number =</span> <span class="dv">10</span>,   <span class="co">## 10-fold</span>
    <span class="dt">summaryFunction =</span> twoClassSummary, <span class="co">## NEW</span>
    <span class="dt">classProbs =</span> <span class="ot">TRUE</span>, <span class="co"># IMPORTANT</span>
    <span class="dt">verboseIter =</span> <span class="ot">FALSE</span>
)
<span class="co">## Train glm with custom trainControl: model</span>
model &lt;-<span class="st"> </span><span class="kw">train</span>(Class <span class="op">~</span><span class="st"> </span>., Sonar,
               <span class="dt">method =</span> <span class="st">&quot;glm&quot;</span>, <span class="co">## to use glm&#39;s logistic regression</span>
               <span class="dt">trControl =</span> myControl)

<span class="co">## Print model to console</span>
<span class="kw">print</span>(model)</code></pre>
<pre><code>## Generalized Linear Model 
## 
## 208 samples
##  60 predictor
##   2 classes: &#39;M&#39;, &#39;R&#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold) 
## Summary of sample sizes: 187, 188, 188, 187, 188, 187, ... 
## Resampling results:
## 
##   ROC       Sens       Spec     
##   0.733447  0.7477273  0.6688889</code></pre>
<blockquote>
<p>Challenge</p>
<p>Define a <code>train</code> object that uses the AUC and 10-fold cross
validation to classify the Sonar data using a logistic regression,
as demonstrated above.</p>
</blockquote>
</div>
</div>
<div id="random-forest" class="section level2">
<h2><span class="header-section-number">5.5</span> Random forest</h2>
<p>Random forest models are accurate and non-linear models and robust to
over-fitting and hence quite popular. They however require
hyperparameters to be tuned manually, like the value <em>k</em> in the
example above.</p>
<p>Building a random forest starts by generating a high number of
individual decision trees. A single decision tree isn’t very accurate,
but many different trees built using different inputs (with
bootstrapped inputs, features and observations) enable us to explore a
broad search space and, once combined, produce accurate models, a
technique called <em>bootstrap aggregation</em> or <em>bagging</em>.</p>
<div id="decision-trees" class="section level3">
<h3><span class="header-section-number">5.5.1</span> Decision trees</h3>
<p>A great advantage of decision trees is that they make a complex
decision simpler by breaking it down into smaller, simpler decisions
using a divide-and-conquer strategy. They basically identify a set of
if-else conditions that split the data according to the value of the
features.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;rpart&quot;</span>) <span class="co">## recursive partitioning</span>
m &lt;-<span class="st"> </span><span class="kw">rpart</span>(Class <span class="op">~</span><span class="st"> </span>., <span class="dt">data =</span> Sonar,
           <span class="dt">method =</span> <span class="st">&quot;class&quot;</span>)
<span class="kw">library</span>(<span class="st">&quot;rpart.plot&quot;</span>)
<span class="kw">rpart.plot</span>(m)</code></pre>
<div class="figure"><span id="fig:rpart"></span>
<img src="IntroMachineLearningWithR_files/figure-html/rpart-1.png" alt="Descision tree with its if-else conditions" width="672" />
<p class="caption">
Figure 5.2: Descision tree with its if-else conditions
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r">p &lt;-<span class="st"> </span><span class="kw">predict</span>(m, Sonar, <span class="dt">type =</span> <span class="st">&quot;class&quot;</span>)
<span class="kw">table</span>(p, Sonar<span class="op">$</span>Class)</code></pre>
<pre><code>##    
## p    M  R
##   M 95 10
##   R 16 87</code></pre>
<p>Decision trees choose splits based on most homogeneous partitions, and
lead to smaller and more homogeneous partitions over their iterations.</p>
<p>An issue with single decision trees is that they can grow, and become
large and complex with many branches, which corresponds to
over-fitting. Over-fitting models noise, rather than general patterns in
the data, focusing on subtle patterns (outliers) that won’t
generalise.</p>
<p>To avoid over-fitting, individual decision trees are pruned. Pruning
can happen as a pre-condition when growing the tree, or afterwards, by
pruning a large tree.</p>
<ul>
<li><p><em>Pre-pruning</em>: stop growing process, i.e stops divide-and-conquer
after a certain number of iterations (grows tree to a certain
predefined level), or requires a minimum number of observations in
each mode to allow splitting.</p></li>
<li><p><em>Post-pruning</em>: grow a large and complex tree, and reduce its size;
nodes and branches that have a negligible effect on the
classification accuracy are removed.</p></li>
</ul>
</div>
<div id="training-a-random-forest" class="section level3">
<h3><span class="header-section-number">5.5.2</span> Training a random forest</h3>
<p>Let’s return to random forests and train a model using the <code>train</code>
function from <em><a href="https://CRAN.R-project.org/package=caret">caret</a></em>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">12</span>)
model &lt;-<span class="st"> </span><span class="kw">train</span>(Class <span class="op">~</span><span class="st"> </span>.,
               <span class="dt">data =</span> Sonar,
               <span class="dt">method =</span> <span class="st">&quot;ranger&quot;</span>)
<span class="kw">print</span>(model)</code></pre>
<pre><code>## Random Forest 
## 
## 208 samples
##  60 predictor
##   2 classes: &#39;M&#39;, &#39;R&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (25 reps) 
## Summary of sample sizes: 208, 208, 208, 208, 208, 208, ... 
## Resampling results across tuning parameters:
## 
##   mtry  splitrule   Accuracy   Kappa    
##    2    gini        0.8090731  0.6131571
##    2    extratrees  0.8136902  0.6234492
##   31    gini        0.7736954  0.5423516
##   31    extratrees  0.8285153  0.6521921
##   60    gini        0.7597299  0.5140905
##   60    extratrees  0.8157646  0.6255929
## 
## Tuning parameter &#39;min.node.size&#39; was held constant at a value of 1
## Accuracy was used to select the optimal model using the largest value.
## The final values used for the model were mtry = 31, splitrule =
##  extratrees and min.node.size = 1.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(model)</code></pre>
<p><img src="IntroMachineLearningWithR_files/figure-html/rfplotmodel-1.png" width="672" /></p>
<p>The main hyperparameter is <em>mtry</em>, i.e. the number of randomly selected
variables used at each split. Two variables produce random models, while
hundreds of variables tend to be less random, but risk
over-fitting. The <code>caret</code> package can automate the tuning of the hyperparameter using a
<strong>grid search</strong>, which can be parametrised by setting <code>tuneLength</code>
(that sets the number of hyperparameter values to test) or directly
defining the <code>tuneGrid</code> (the hyperparameter values), which requires
knowledge of the model.</p>
<pre class="sourceCode r"><code class="sourceCode r">model &lt;-<span class="st"> </span><span class="kw">train</span>(Class <span class="op">~</span><span class="st"> </span>.,
               <span class="dt">data =</span> Sonar,
               <span class="dt">method =</span> <span class="st">&quot;ranger&quot;</span>,
               <span class="dt">tuneLength =</span> <span class="dv">5</span>)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">42</span>)
myGrid &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">mtry =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">40</span>, <span class="dv">60</span>),
                      <span class="dt">splitrule =</span> <span class="kw">c</span>(<span class="st">&quot;gini&quot;</span>, <span class="st">&quot;extratrees&quot;</span>),
                      <span class="dt">min.node.size =</span> <span class="dv">1</span>) <span class="co">## Minimal node size; default 1 for classification</span>
model &lt;-<span class="st"> </span><span class="kw">train</span>(Class <span class="op">~</span><span class="st"> </span>.,
               <span class="dt">data =</span> Sonar,
               <span class="dt">method =</span> <span class="st">&quot;ranger&quot;</span>,
               <span class="dt">tuneGrid =</span> myGrid,
               <span class="dt">trControl =</span> <span class="kw">trainControl</span>(<span class="dt">method =</span> <span class="st">&quot;cv&quot;</span>,
                                       <span class="dt">number =</span> <span class="dv">5</span>,
                                       <span class="dt">verboseIter =</span> <span class="ot">FALSE</span>))
<span class="kw">print</span>(model)</code></pre>
<pre><code>## Random Forest 
## 
## 208 samples
##  60 predictor
##   2 classes: &#39;M&#39;, &#39;R&#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (5 fold) 
## Summary of sample sizes: 166, 167, 167, 167, 165 
## Resampling results across tuning parameters:
## 
##   mtry  splitrule   Accuracy   Kappa    
##    5    gini        0.8076277  0.6098253
##    5    extratrees  0.8416579  0.6784745
##   10    gini        0.7927667  0.5799348
##   10    extratrees  0.8418848  0.6791453
##   20    gini        0.7882316  0.5718852
##   20    extratrees  0.8516355  0.6991879
##   40    gini        0.7880048  0.5716461
##   40    extratrees  0.8371229  0.6695638
##   60    gini        0.7833482  0.5613525
##   60    extratrees  0.8322448  0.6599318
## 
## Tuning parameter &#39;min.node.size&#39; was held constant at a value of 1
## Accuracy was used to select the optimal model using the largest value.
## The final values used for the model were mtry = 20, splitrule =
##  extratrees and min.node.size = 1.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(model)</code></pre>
<p><img src="IntroMachineLearningWithR_files/figure-html/tuneGrid-1.png" width="672" /></p>
<blockquote>
<p>Challenge</p>
<p>Experiment with training a random forest model as described above,
by using 5-fold cross validation, and setting a <code>tuneLength</code> of 5.</p>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">42</span>)
model &lt;-<span class="st"> </span><span class="kw">train</span>(Class <span class="op">~</span><span class="st"> </span>.,
               <span class="dt">data =</span> Sonar,
               <span class="dt">method =</span> <span class="st">&quot;ranger&quot;</span>,
               <span class="dt">tuneLength =</span> <span class="dv">5</span>,
               <span class="dt">trControl =</span> <span class="kw">trainControl</span>(<span class="dt">method =</span> <span class="st">&quot;cv&quot;</span>,
                                        <span class="dt">number =</span> <span class="dv">5</span>,
                                        <span class="dt">verboseIter =</span> <span class="ot">FALSE</span>))
<span class="kw">plot</span>(model)</code></pre>
<img src="IntroMachineLearningWithR_files/figure-html/rftrainsol-1.png" width="672" />
</details>
</div>
</div>
<div id="data-pre-processing-1" class="section level2">
<h2><span class="header-section-number">5.6</span> Data pre-processing</h2>
<div id="missing-values" class="section level3">
<h3><span class="header-section-number">5.6.1</span> Missing values</h3>
<p>Real datasets often come with missing values. In R, these should be
encoded using <code>NA</code>. There are basically two approaches to deal with
such cases.</p>
<ul>
<li><p>Drop the observations with missing values, or, if one feature
contains a very high proportion of NAs, drop the feature
altogether. These approaches are only applicable when the proportion
of missing values is relatively small. Otherwise, it could lead to
losing too much data.</p></li>
<li><p>Impute (replace) missing values.</p></li>
</ul>
<p>Data imputation can however have critical consequences depending on the
proportion of missing values and their nature. From a statistical
point of view, missing values are classified as <em>missing completely at
random</em> (MCAR), <em>missing at random</em> (MAR) or <em>missing not at random</em>
(MNAR), and the type of the missing values will influence the
efficiency of the imputation method.</p>
<p>The figure below shows how different imputation methods perform
depending on the proportion and nature of missing values
(from <a href="https://www.ncbi.nlm.nih.gov/pubmed/26906401">Lazar <em>et al.</em></a>,
on quantitative proteomics data).</p>
<div class="figure">
<img src="figure/imp.png" alt="Normalised RMSE (RMSE-observation standard deviation ration) describing the effect of different imputation methods depending on the nature and proportion of the missing values: kNN (a), SVDimpute (b), MLE (c), MinDet (d), and MinProb (e)." />
<p class="caption">Normalised RMSE (RMSE-observation standard deviation ration) describing the effect of different imputation methods depending on the nature and proportion of the missing values: kNN (a), SVDimpute (b), MLE (c), MinDet (d), and MinProb (e).</p>
</div>
<p>Let’s start by simulating a dataset containing missing values using
the <code>mtcars</code> dataset. Below, we will want to predict the <code>mpg</code>
variable using <code>cyl</code>, <code>disp</code>, and <code>hp</code>, with the latter containing 10
missing values.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(mtcars)
mtcars[<span class="kw">sample</span>(<span class="kw">nrow</span>(mtcars), <span class="dv">10</span>), <span class="st">&quot;hp&quot;</span>] &lt;-<span class="st"> </span><span class="ot">NA</span>
Y &lt;-<span class="st"> </span>mtcars<span class="op">$</span>mpg    <span class="co">## target variable</span>
X &lt;-<span class="st"> </span>mtcars[, <span class="dv">2</span><span class="op">:</span><span class="dv">4</span>] <span class="co">## predictors</span></code></pre>
<p>If we now wanted to train a model (using the non-formula interface):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">try</span>(<span class="kw">train</span>(X, Y))</code></pre>
<pre><code>## note: only 2 unique complexity parameters in default grid. Truncating the grid to 2 .
## 
## Something is wrong; all the RMSE metric values are missing:
##       RMSE        Rsquared        MAE     
##  Min.   : NA   Min.   : NA   Min.   : NA  
##  1st Qu.: NA   1st Qu.: NA   1st Qu.: NA  
##  Median : NA   Median : NA   Median : NA  
##  Mean   :NaN   Mean   :NaN   Mean   :NaN  
##  3rd Qu.: NA   3rd Qu.: NA   3rd Qu.: NA  
##  Max.   : NA   Max.   : NA   Max.   : NA  
##  NA&#39;s   :2     NA&#39;s   :2     NA&#39;s   :2    
## Error : Stopping</code></pre>
<p>(Note that the occurrence of the error will depend on the model
chosen.)</p>
<p>We could perform imputation manually, but <em><a href="https://CRAN.R-project.org/package=caret">caret</a></em>
provides a whole range of pre-processing methods, including imputation
methods, that can directly be passed when training the model.</p>
</div>
<div id="median-imputation" class="section level3">
<h3><span class="header-section-number">5.6.2</span> Median imputation</h3>
<p>Imputation using median of features. This method works well if the
data are missing at random.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">train</span>(X, Y, <span class="dt">preProcess =</span> <span class="st">&quot;medianImpute&quot;</span>)</code></pre>
<pre><code>## note: only 2 unique complexity parameters in default grid. Truncating the grid to 2 .</code></pre>
<pre><code>## Random Forest 
## 
## 32 samples
##  3 predictor
## 
## Pre-processing: median imputation (3) 
## Resampling: Bootstrapped (25 reps) 
## Summary of sample sizes: 32, 32, 32, 32, 32, 32, ... 
## Resampling results across tuning parameters:
## 
##   mtry  RMSE      Rsquared   MAE     
##   2     2.345716  0.8457441  1.923509
##   3     2.433508  0.8337201  2.007780
## 
## RMSE was used to select the optimal model using the smallest value.
## The final value used for the model was mtry = 2.</code></pre>
<p>Imputing using caret also allows us to optimise the imputation based on
the cross validation splits, as <code>train</code> will do median imputation
inside each fold.</p>
</div>
<div id="knn-imputation" class="section level3">
<h3><span class="header-section-number">5.6.3</span> kNN imputation</h3>
<p>If there is a systematic bias in the missing values, then median
imputation is known to produce incorrect results. kNN imputation will
impute missing values using other, similar non-missing rows. The
default value is 5.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">train</span>(X, Y, <span class="dt">preProcess =</span> <span class="st">&quot;knnImpute&quot;</span>)</code></pre>
<pre><code>## note: only 2 unique complexity parameters in default grid. Truncating the grid to 2 .</code></pre>
<pre><code>## Random Forest 
## 
## 32 samples
##  3 predictor
## 
## Pre-processing: nearest neighbor imputation (3), centered (3), scaled (3) 
## Resampling: Bootstrapped (25 reps) 
## Summary of sample sizes: 32, 32, 32, 32, 32, 32, ... 
## Resampling results across tuning parameters:
## 
##   mtry  RMSE      Rsquared   MAE     
##   2     2.603630  0.8300018  2.145504
##   3     2.635956  0.8228652  2.171091
## 
## RMSE was used to select the optimal model using the smallest value.
## The final value used for the model was mtry = 2.</code></pre>
</div>
</div>
<div id="scaling-and-centering" class="section level2">
<h2><span class="header-section-number">5.7</span> Scaling and centering</h2>
<p>We have seen in the <em>Unsupervised learning</em> chapter how data at
different scales can substantially disrupt a learning
algorithm. Scaling (division by the standard deviation) and centering
(subtraction of the mean) can also be applied directly during model
training by setting. Note that they are set to be applied by default
prior to training.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">train</span>(X, Y, <span class="dt">preProcess =</span> <span class="st">&quot;scale&quot;</span>)
<span class="kw">train</span>(X, Y, <span class="dt">preProcess =</span> <span class="st">&quot;center&quot;</span>)</code></pre>
<p>As we have discussed in the section on Principal Component
Analysis, PCA can be used as pre-processing method, generating a set
of high-variance and perpendicular predictors, preventing
collinearity.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">train</span>(X, Y, <span class="dt">preProcess =</span> <span class="st">&quot;pca&quot;</span>)</code></pre>
<div id="multiple-pre-processing-methods" class="section level3">
<h3><span class="header-section-number">5.7.1</span> Multiple pre-processing methods</h3>
<p>It is possible to chain multiple processing methods: imputation,
center, scale, pca.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">train</span>(X, Y, <span class="dt">preProcess =</span> <span class="kw">c</span>(<span class="st">&quot;knnImpute&quot;</span>, <span class="st">&quot;center&quot;</span>, <span class="st">&quot;scale&quot;</span>, <span class="st">&quot;pca&quot;</span>))</code></pre>
<pre><code>## note: only 2 unique complexity parameters in default grid. Truncating the grid to 2 .</code></pre>
<pre><code>## Random Forest 
## 
## 32 samples
##  3 predictor
## 
## Pre-processing: nearest neighbor imputation (3), centered (3), scaled
##  (3), principal component signal extraction (3) 
## Resampling: Bootstrapped (25 reps) 
## Summary of sample sizes: 32, 32, 32, 32, 32, 32, ... 
## Resampling results across tuning parameters:
## 
##   mtry  RMSE      Rsquared   MAE     
##   2     2.549263  0.8245732  2.125463
##   3     2.553001  0.8256242  2.131125
## 
## RMSE was used to select the optimal model using the smallest value.
## The final value used for the model was mtry = 2.</code></pre>
<p>The pre-processing methods above represent a classical order of
operations, starting with data imputation to remove missing values,
then centering and scaling, prior to PCA.</p>
<!-- ## Low information predictors -->
<!-- To remove, for example constant or random variables, or variables with -->
<!-- low variance. -->
<!-- ```{r, eval=FALSE} -->
<!-- train(X, Y, preProcess = c("zv", ...))  ## remove constant (zero-variance) columns -->
<!-- train(X, Y, preProcess = c("nzv", ...)) ## nearly constant columns -->
<!-- ``` -->
<p>For further details, see <code>?preProcess</code>.</p>
</div>
</div>
<div id="model-selection-1" class="section level2">
<h2><span class="header-section-number">5.8</span> Model selection</h2>
<p>In this final section, we are going to compare different predictive
models and choose the best one using the tools presented in the
previous sections.</p>
<p>To to so, we are going to first create a set of common training
controller object with the same train/test folds and model evaluation
metrics that we will re-use. This is important to guarantee fair
comparison between the different models.</p>
<p>For this section, we are going to use the <code>churn</code> data. Below, we see
that about 15% of the customers churn. It is important to maintain
this proportion in all of the folds.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;C50&quot;</span>)
<span class="kw">data</span>(churn)
<span class="kw">table</span>(churnTrain<span class="op">$</span>churn)<span class="op">/</span><span class="kw">nrow</span>(churnTrain)</code></pre>
<pre><code>## 
##       yes        no 
## 0.1449145 0.8550855</code></pre>
<p>Previously, when creating a train control object, we specified the
method as <code>"cv"</code> and the number of folds. Now, as we want the same
folds to be re-used over multiple model training rounds, we are going
to pass the train/test splits directly. These splits are created with
the <code>createFolds</code> function, which creates a list (here of length 5)
containing the element indices for each fold.</p>
<pre class="sourceCode r"><code class="sourceCode r">myFolds &lt;-<span class="st"> </span><span class="kw">createFolds</span>(churnTrain<span class="op">$</span>churn, <span class="dt">k =</span> <span class="dv">5</span>)
<span class="kw">str</span>(myFolds)</code></pre>
<pre><code>## List of 5
##  $ Fold1: int [1:667] 3 7 13 17 20 36 39 48 52 62 ...
##  $ Fold2: int [1:667] 4 10 12 24 25 29 41 42 47 50 ...
##  $ Fold3: int [1:667] 6 15 19 21 22 26 28 32 33 34 ...
##  $ Fold4: int [1:666] 5 9 16 30 31 37 44 45 46 53 ...
##  $ Fold5: int [1:666] 1 2 8 11 14 18 23 27 35 43 ...</code></pre>
<blockquote>
<p>Challenge</p>
<p>Verify that the folds maintain the proportion of yes/no results.</p>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sapply</span>(myFolds, <span class="cf">function</span>(i) {
    <span class="kw">table</span>(churnTrain<span class="op">$</span>churn[i])<span class="op">/</span><span class="kw">length</span>(i)
})</code></pre>
<pre><code>##         Fold1     Fold2     Fold3     Fold4     Fold5
## yes 0.1454273 0.1454273 0.1454273 0.1441441 0.1441441
## no  0.8545727 0.8545727 0.8545727 0.8558559 0.8558559</code></pre>
</details>
<p>We can now a train control object to be reused consistently for
different model trainings.</p>
<pre class="sourceCode r"><code class="sourceCode r">myControl &lt;-<span class="st"> </span><span class="kw">trainControl</span>(
  <span class="dt">summaryFunction =</span> twoClassSummary,
  <span class="dt">classProb =</span> <span class="ot">TRUE</span>,
  <span class="dt">verboseIter =</span> <span class="ot">FALSE</span>,
  <span class="dt">savePredictions =</span> <span class="ot">TRUE</span>,
  <span class="dt">index =</span> myFolds
)</code></pre>
<div id="glmnet-model" class="section level3">
<h3><span class="header-section-number">5.8.1</span> <code>glmnet</code> model</h3>
<p>The <code>glmnet</code> is a linear model with built-in variable selection and
coefficient regularisation.</p>
<pre class="sourceCode r"><code class="sourceCode r">glm_model &lt;-<span class="st"> </span><span class="kw">train</span>(churn <span class="op">~</span><span class="st"> </span>.,
                   churnTrain,
                   <span class="dt">metric =</span> <span class="st">&quot;ROC&quot;</span>,
                   <span class="dt">method =</span> <span class="st">&quot;glmnet&quot;</span>,
                   <span class="dt">tuneGrid =</span> <span class="kw">expand.grid</span>(
                       <span class="dt">alpha =</span> <span class="dv">0</span><span class="op">:</span><span class="dv">1</span>,
                       <span class="dt">lambda =</span> <span class="dv">0</span><span class="op">:</span><span class="dv">10</span><span class="op">/</span><span class="dv">10</span>),
                   <span class="dt">trControl =</span> myControl)
<span class="kw">print</span>(glm_model)</code></pre>
<pre><code>## glmnet 
## 
## 3333 samples
##   19 predictor
##    2 classes: &#39;yes&#39;, &#39;no&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (5 reps) 
## Summary of sample sizes: 667, 667, 667, 666, 666 
## Resampling results across tuning parameters:
## 
##   alpha  lambda  ROC        Sens         Spec     
##   0      0.0     0.7575175  0.249475840  0.9567544
##   0      0.1     0.7769689  0.070920191  0.9921053
##   0      0.2     0.7785410  0.016561567  0.9986842
##   0      0.3     0.7784171  0.004659196  0.9994737
##   0      0.4     0.7780007  0.000000000  1.0000000
##   0      0.5     0.7775646  0.000000000  1.0000000
##   0      0.6     0.7771289  0.000000000  1.0000000
##   0      0.7     0.7767893  0.000000000  1.0000000
##   0      0.8     0.7764375  0.000000000  1.0000000
##   0      0.9     0.7761664  0.000000000  1.0000000
##   0      1.0     0.7759360  0.000000000  1.0000000
##   1      0.0     0.7200047  0.291397893  0.9434211
##   1      0.1     0.5216114  0.000000000  1.0000000
##   1      0.2     0.5000000  0.000000000  1.0000000
##   1      0.3     0.5000000  0.000000000  1.0000000
##   1      0.4     0.5000000  0.000000000  1.0000000
##   1      0.5     0.5000000  0.000000000  1.0000000
##   1      0.6     0.5000000  0.000000000  1.0000000
##   1      0.7     0.5000000  0.000000000  1.0000000
##   1      0.8     0.5000000  0.000000000  1.0000000
##  [ reached getOption(&quot;max.print&quot;) -- omitted 2 rows ]
## 
## ROC was used to select the optimal model using the largest value.
## The final values used for the model were alpha = 0 and lambda = 0.2.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(glm_model)</code></pre>
<p><img src="IntroMachineLearningWithR_files/figure-html/glmnetmodel-1.png" width="672" /></p>
<p>Below, we are going to repeat this same modelling with a variety of
different classifiers, some of which we haven’t looked at. This
illustrates another advantage of of using <strong>meta-packages</strong> such as
<em><a href="https://CRAN.R-project.org/package=caret">caret</a></em>, that provide a consistant interface to different
backends (in this case for machine learning). Once we have mastered
the interface, it becomes easy to apply it to a new backend.</p>
<p>Note that some of the model training below will take some time to run,
depending on the tuning parameter settings.</p>
</div>
<div id="random-forest-model" class="section level3">
<h3><span class="header-section-number">5.8.2</span> random forest model</h3>
<blockquote>
<p>Challenge</p>
<p>Apply a random forest model, making sure you reuse the same train
control object.</p>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r">rf_model &lt;-<span class="st"> </span><span class="kw">train</span>(churn <span class="op">~</span><span class="st"> </span>.,
                  churnTrain,
                  <span class="dt">metric =</span> <span class="st">&quot;ROC&quot;</span>,
                  <span class="dt">method =</span> <span class="st">&quot;ranger&quot;</span>,
                  <span class="dt">tuneGrid =</span> <span class="kw">expand.grid</span>(
                      <span class="dt">mtry =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">19</span>),
                      <span class="dt">splitrule =</span> <span class="kw">c</span>(<span class="st">&quot;gini&quot;</span>, <span class="st">&quot;extratrees&quot;</span>),
                      <span class="dt">min.node.size =</span> <span class="dv">1</span>),
                  <span class="dt">trControl =</span> myControl)
<span class="kw">print</span>(rf_model)</code></pre>
<pre><code>## Random Forest 
## 
## 3333 samples
##   19 predictor
##    2 classes: &#39;yes&#39;, &#39;no&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (5 reps) 
## Summary of sample sizes: 667, 667, 667, 666, 666 
## Resampling results across tuning parameters:
## 
##   mtry  splitrule   ROC        Sens        Spec     
##    2    gini        0.8652359  0.02331205  0.9999123
##    2    extratrees  0.8297199  0.00000000  1.0000000
##    5    gini        0.8876968  0.20913497  0.9974561
##    5    extratrees  0.8729902  0.04659731  0.9995614
##   10    gini        0.8936162  0.39389083  0.9923684
##   10    extratrees  0.8872372  0.20134956  0.9974561
##   19    gini        0.8977501  0.58076073  0.9850000
##   19    extratrees  0.8956725  0.35972205  0.9914035
## 
## Tuning parameter &#39;min.node.size&#39; was held constant at a value of 1
## ROC was used to select the optimal model using the largest value.
## The final values used for the model were mtry = 19, splitrule = gini
##  and min.node.size = 1.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(rf_model)</code></pre>
<img src="IntroMachineLearningWithR_files/figure-html/rfmodel-1.png" width="672" />
</details>
</div>
<div id="knn-model" class="section level3">
<h3><span class="header-section-number">5.8.3</span> kNN model</h3>
<blockquote>
<p>Challenge</p>
<p>Apply a kNN model, making sure you reuse the same train
control object.</p>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r">knn_model &lt;-<span class="st"> </span><span class="kw">train</span>(churn <span class="op">~</span><span class="st"> </span>.,
                   churnTrain,
                   <span class="dt">metric =</span> <span class="st">&quot;ROC&quot;</span>,
                   <span class="dt">method =</span> <span class="st">&quot;knn&quot;</span>,
                   <span class="dt">tuneLength =</span> <span class="dv">20</span>,
                   <span class="dt">trControl =</span> myControl)
<span class="kw">print</span>(knn_model)</code></pre>
<pre><code>## k-Nearest Neighbors 
## 
## 3333 samples
##   19 predictor
##    2 classes: &#39;yes&#39;, &#39;no&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (5 reps) 
## Summary of sample sizes: 667, 667, 667, 666, 666 
## Resampling results across tuning parameters:
## 
##   k   ROC        Sens        Spec     
##    5  0.6598643  0.21377542  0.9773684
##    7  0.6686225  0.19773199  0.9846491
##    9  0.6769357  0.18012612  0.9898246
##   11  0.6821201  0.16097388  0.9910526
##   13  0.6902054  0.15114003  0.9924561
##   15  0.6910103  0.14441231  0.9941228
##   17  0.6935052  0.13199047  0.9945614
##   19  0.6944057  0.12422782  0.9951754
##   21  0.6956445  0.11853369  0.9957018
##   23  0.6970316  0.10767027  0.9968421
##   25  0.6990557  0.10249562  0.9969298
##   27  0.6990448  0.09835054  0.9975439
##   29  0.7013191  0.08385883  0.9979825
##   31  0.7011835  0.07816471  0.9981579
##   33  0.7023618  0.06988258  0.9984211
##   35  0.7026399  0.06160314  0.9985965
##   37  0.7041429  0.05487408  0.9985088
##   39  0.7034029  0.04918397  0.9988596
##   41  0.7027796  0.04452745  0.9991228
##   43  0.7026078  0.03883199  0.9992105
## 
## ROC was used to select the optimal model using the largest value.
## The final value used for the model was k = 37.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(knn_model)</code></pre>
<img src="IntroMachineLearningWithR_files/figure-html/knnmodel-1.png" width="672" />
</details>
</div>
<div id="support-vector-machine-model" class="section level3">
<h3><span class="header-section-number">5.8.4</span> Support vector machine model</h3>
<blockquote>
<p>Challenge</p>
<p>Apply a svm model, making sure you reuse the same train control
object. Hint: Look at <code>names(getModelInfo())</code> for all possible model
names.</p>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r">svm_model &lt;-<span class="st"> </span><span class="kw">train</span>(churn <span class="op">~</span><span class="st"> </span>.,
                   churnTrain,
                   <span class="dt">metric =</span> <span class="st">&quot;ROC&quot;</span>,
                   <span class="dt">method =</span> <span class="st">&quot;svmRadial&quot;</span>,
                   <span class="dt">tuneLength =</span> <span class="dv">10</span>,
                   <span class="dt">trControl =</span> myControl)
<span class="kw">print</span>(svm_model)</code></pre>
<pre><code>## Support Vector Machines with Radial Basis Function Kernel 
## 
## 3333 samples
##   19 predictor
##    2 classes: &#39;yes&#39;, &#39;no&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (5 reps) 
## Summary of sample sizes: 667, 667, 667, 666, 666 
## Resampling results across tuning parameters:
## 
##   C       ROC        Sens        Spec     
##     0.25  0.8079660  0.07454446  0.9907895
##     0.50  0.8078943  0.06003936  0.9943860
##     1.00  0.8079884  0.09215836  0.9890351
##     2.00  0.8081908  0.13717315  0.9813158
##     4.00  0.8131150  0.13920419  0.9859649
##     8.00  0.8156179  0.12888300  0.9879825
##    16.00  0.8096085  0.17804689  0.9821930
##    32.00  0.8032513  0.15837383  0.9836842
##    64.00  0.7985012  0.17082112  0.9810526
##   128.00  0.7965813  0.15939002  0.9826316
## 
## Tuning parameter &#39;sigma&#39; was held constant at a value of 0.007417943
## ROC was used to select the optimal model using the largest value.
## The final values used for the model were sigma = 0.007417943 and C = 8.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(svm_model)</code></pre>
<img src="IntroMachineLearningWithR_files/figure-html/svmmodel-1.png" width="672" />
</details>
</div>
<div id="naive-bayes" class="section level3">
<h3><span class="header-section-number">5.8.5</span> Naive Bayes</h3>
<blockquote>
<p>Challenge</p>
<p>Apply a naive Bayes model, making sure you reuse the same train
control object.</p>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r">nb_model &lt;-<span class="st"> </span><span class="kw">train</span>(churn <span class="op">~</span><span class="st"> </span>.,
                  churnTrain,
                  <span class="dt">metric =</span> <span class="st">&quot;ROC&quot;</span>,
                  <span class="dt">method =</span> <span class="st">&quot;naive_bayes&quot;</span>,
                  <span class="dt">trControl =</span> myControl)

<span class="kw">print</span>(nb_model)</code></pre>
<pre><code>## Naive Bayes 
## 
## 3333 samples
##   19 predictor
##    2 classes: &#39;yes&#39;, &#39;no&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (5 reps) 
## Summary of sample sizes: 667, 667, 667, 666, 666 
## Resampling results across tuning parameters:
## 
##   usekernel  ROC        Sens       Spec      
##   FALSE      0.5540359  0.9497409  0.07912281
##    TRUE      0.8086525  0.0000000  1.00000000
## 
## Tuning parameter &#39;laplace&#39; was held constant at a value of 0
## 
## Tuning parameter &#39;adjust&#39; was held constant at a value of 1
## ROC was used to select the optimal model using the largest value.
## The final values used for the model were laplace = 0, usekernel = TRUE
##  and adjust = 1.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(nb_model)</code></pre>
<img src="IntroMachineLearningWithR_files/figure-html/nbmodel-1.png" width="672" />
</details>
</div>
<div id="comparing-models" class="section level3">
<h3><span class="header-section-number">5.8.6</span> Comparing models</h3>
<p>We can now use the <code>caret::resamples</code> function that will compare the
models and pick the one with the highest AUC and lowest AUC standard
deviation.</p>
<pre class="sourceCode r"><code class="sourceCode r">model_list &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">glmmet =</span> glm_model,
                   <span class="dt">rf =</span> rf_model,
                   <span class="dt">knn =</span> knn_model,
                   <span class="dt">svm =</span> svm_model,
                   <span class="dt">nb =</span> nb_model)
resamp &lt;-<span class="st"> </span><span class="kw">resamples</span>(model_list)
resamp</code></pre>
<pre><code>## 
## Call:
## resamples.default(x = model_list)
## 
## Models: glmmet, rf, knn, svm, nb 
## Number of resamples: 5 
## Performance metrics: ROC, Sens, Spec 
## Time estimates for: everything, final model fit</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(resamp)</code></pre>
<pre><code>## 
## Call:
## summary.resamples(object = resamp)
## 
## Models: glmmet, rf, knn, svm, nb 
## Number of resamples: 5 
## 
## ROC 
##             Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA&#39;s
## glmmet 0.7739183 0.7755329 0.7801770 0.7785410 0.7813153 0.7817614    0
## rf     0.8834362 0.8924689 0.8982229 0.8977501 0.9050575 0.9095653    0
## knn    0.6895458 0.7018430 0.7074902 0.7041429 0.7091369 0.7126983    0
## svm    0.8041321 0.8094912 0.8188858 0.8156179 0.8220173 0.8235629    0
## nb     0.7954270 0.8004363 0.8118887 0.8086525 0.8157215 0.8197891    0
## 
## Sens 
##               Min.    1st Qu.     Median       Mean    3rd Qu.       Max.
## glmmet 0.007772021 0.01291990 0.01813472 0.01656157 0.02072539 0.02325581
## rf     0.511627907 0.54663212 0.58808290 0.58076073 0.62015504 0.63730570
## knn    0.012919897 0.02590674 0.06476684 0.05487408 0.08010336 0.09067358
## svm    0.106217617 0.11111111 0.12953368 0.12888300 0.14470284 0.15284974
## nb     0.000000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000
##        NA&#39;s
## glmmet    0
## rf        0
## knn       0
## svm       0
## nb        0
## 
## Spec 
##             Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA&#39;s
## glmmet 0.9973684 0.9982456 0.9986842 0.9986842 0.9991228 1.0000000    0
## rf     0.9763158 0.9820175 0.9846491 0.9850000 0.9907895 0.9912281    0
## knn    0.9969298 0.9978070 0.9982456 0.9985088 0.9995614 1.0000000    0
## svm    0.9828947 0.9881579 0.9885965 0.9879825 0.9890351 0.9912281    0
## nb     1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000    0</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">lattice<span class="op">::</span><span class="kw">bwplot</span>(resamp, <span class="dt">metric =</span> <span class="st">&quot;ROC&quot;</span>)</code></pre>
<div class="figure"><span id="fig:plotresam"></span>
<img src="IntroMachineLearningWithR_files/figure-html/plotresam-1.png" alt="Comparing distributions of AUC values for various models." width="672" />
<p class="caption">
Figure 5.3: Comparing distributions of AUC values for various models.
</p>
</div>
</div>
<div id="pre-processing-1" class="section level3">
<h3><span class="header-section-number">5.8.7</span> Pre-processing</h3>
<p>The random forest appears to be the best one. This might be related to
its ability to cope well with different types of input and require
little pre-processing.</p>
<blockquote>
<p>Challenge</p>
<p>If you haven’t done so, consider pre-processing the data prior to
training for a model that didn’t perform well and assess whether
pre-processing affected the modelling.</p>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r">svm_model1 &lt;-<span class="st"> </span><span class="kw">train</span>(churn <span class="op">~</span><span class="st"> </span>.,
                    churnTrain,
                    <span class="dt">metric =</span> <span class="st">&quot;ROC&quot;</span>,
                    <span class="dt">method =</span> <span class="st">&quot;svmRadial&quot;</span>,
                    <span class="dt">tuneLength =</span> <span class="dv">10</span>,
                    <span class="dt">trControl =</span> myControl)

svm_model2 &lt;-<span class="st"> </span><span class="kw">train</span>(churn <span class="op">~</span><span class="st"> </span>.,
                    churnTrain[, <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">6</span><span class="op">:</span><span class="dv">20</span>)],
                    <span class="dt">metric =</span> <span class="st">&quot;ROC&quot;</span>,
                    <span class="dt">method =</span> <span class="st">&quot;svmRadial&quot;</span>,
                    <span class="dt">preProcess =</span> <span class="kw">c</span>(<span class="st">&quot;scale&quot;</span>, <span class="st">&quot;center&quot;</span>, <span class="st">&quot;pca&quot;</span>),
                    <span class="dt">tuneLength =</span> <span class="dv">10</span>,
                    <span class="dt">trControl =</span> myControl)

model_list &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">svm1 =</span> svm_model1,
                   <span class="dt">svm2 =</span> svm_model2)
resamp &lt;-<span class="st"> </span><span class="kw">resamples</span>(model_list)
<span class="kw">summary</span>(resamp)</code></pre>
<pre><code>## 
## Call:
## summary.resamples(object = resamp)
## 
## Models: svm1, svm2 
## Number of resamples: 5 
## 
## ROC 
##           Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA&#39;s
## svm1 0.8036629 0.8092821 0.8188131 0.8153931 0.8215560 0.8236513    0
## svm2 0.8114933 0.8203550 0.8211070 0.8233570 0.8297328 0.8340969    0
## 
## Sens 
##           Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA&#39;s
## svm1 0.1062176 0.1295337 0.1472868 0.1614746 0.2067183 0.2176166    0
## svm2 0.3875969 0.3963731 0.4196891 0.4120148 0.4237726 0.4326425    0
## 
## Spec 
##           Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA&#39;s
## svm1 0.9745614 0.9828947 0.9842105 0.9847368 0.9890351 0.9929825    0
## svm2 0.9736842 0.9745614 0.9745614 0.9769298 0.9780702 0.9837719    0</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bwplot</span>(resamp, <span class="dt">metric =</span> <span class="st">&quot;ROC&quot;</span>)</code></pre>
<img src="IntroMachineLearningWithR_files/figure-html/svmmodel2-1.png" width="672" />
</details>
</div>
<div id="predict-using-the-best-model" class="section level3">
<h3><span class="header-section-number">5.8.8</span> Predict using the best model</h3>
<blockquote>
<p>Challenge</p>
<p>Choose the best model using the <code>resamples</code> function and comparing
the results and apply it to predict the <code>churnTest</code> labels.</p>
</blockquote>
<details>
<pre class="sourceCode r"><code class="sourceCode r">p &lt;-<span class="st"> </span><span class="kw">predict</span>(rf_model, churnTest)
<span class="kw">confusionMatrix</span>(p, churnTest<span class="op">$</span>churn)</code></pre>
<pre><code>## Confusion Matrix and Statistics
## 
##           Reference
## Prediction  yes   no
##        yes  166    3
##        no    58 1440
##                                           
##                Accuracy : 0.9634          
##                  95% CI : (0.9532, 0.9719)
##     No Information Rate : 0.8656          
##     P-Value [Acc &gt; NIR] : &lt; 2.2e-16       
##                                           
##                   Kappa : 0.8245          
##                                           
##  Mcnemar&#39;s Test P-Value : 4.712e-12       
##                                           
##             Sensitivity : 0.74107         
##             Specificity : 0.99792         
##          Pos Pred Value : 0.98225         
##          Neg Pred Value : 0.96128         
##              Prevalence : 0.13437         
##          Detection Rate : 0.09958         
##    Detection Prevalence : 0.10138         
##       Balanced Accuracy : 0.86950         
##                                           
##        &#39;Positive&#39; Class : yes             
## </code></pre>
</details>

</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="1">
<li id="fn1"><p>There are exactly 238 available
methods. See
<a href="http://topepo.github.io/caret/train-models-by-tag.html" class="uri">http://topepo.github.io/caret/train-models-by-tag.html</a> for
details.<a href="supervised-learning.html#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="unsupervised-learning.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="final-notes.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
